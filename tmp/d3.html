<!-- NOTE: This is a temporary self-contained sandbox for experimenting with d3 components to be used in the SET application. It will eventually be refactored and integrated into the React app. -->

<!DOCTYPE html>
<head>
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&amp;lang=en" />
</head>

<meta charset="utf-8">
<style>

body {
  background: #202A2B;
  font-family: 'Open Sans';
}

.axis {
  clip-path: url(#clip);
}

.dots {
  clip-path: url(#clip);
}

.focus-area {
  fill: #EDEFEF;
}

.axis path {
  stroke-width: 2px;
}

.axis .tick text {
  font-size: 12px;
  font-family: 'Open Sans';
}

.brush rect.selection {
  fill: none;
  stroke: none;
}

</style>
<svg width="1000" height="700"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

// var unselectColor = '#565658';
var unselectColor = '#666';
// var selectColor = '#BCDCDE';
var selectColor = '#70B6BC';

var brushHeight = 15;

// Conception to prenatal: 40 weeks
// Infant to toddler: 0 to 36 months (40 to 196 weeks)
// Childhood to adolescence: 3 to 13 years (196 to 716)
var xLengths = [10, 6, 5] // number of ticks in each interval
var xProps = xLengths.map(function(x) { return x / 21; });
// ~52.18 weeks in a year
// add 40 weeks for to account for gestation
var y2w = function(x) { return x * (365.25 / 7) + 40; }
var w2y = function(x) { return (x - 40) / (365.25 / 7); }
// ~4.35 weeks in a month
var m2w = function(x) { return x * (365.25 / 12 / 7) + 40; }
var w2m = function(x) { return (x - 40) / (365.25 / 12 / 7); }

var xTicks = [
  0, 4, 8, 12, 16, 20, 24, 28, 32, 36,
  m2w(0), m2w(6), m2w(12), m2w(18), m2w(24), m2w(30),
  y2w(3), y2w(5), y2w(7), y2w(9), y2w(11)
];

// minor ticks
var xTicks2 = [
  2, 6, 10, 14, 18, 22, 26, 30, 34, 38,
  m2w(3), m2w(9), m2w(15), m2w(21), m2w(27), m2w(33),
  y2w(4), y2w(6), y2w(8), y2w(10), y2w(12)
];

// major ticks
var xTicks3 = [
  0, m2w(0), y2w(3), y2w(13)
];

var svg = d3.select('svg'),
    marginFoc = {top: 40, right: 20, bottom: 30, left: 40},
    marginCtx = {top: 0, right: 20, bottom: 700, left: 40}, // bottom should be svg height
    width = +svg.attr('width') - marginFoc.left - marginFoc.right,
    heightFoc = +svg.attr('height') - marginFoc.top - marginFoc.bottom,
    heightCtx = +svg.attr('height') - marginCtx.top - marginCtx.bottom;

var focAxisPad = 25;

var xDomain = [0, 40, 196, 716];
var xRange = [0, width * xProps[0], width * (xProps[0] + xProps[1]), width];

var xScaleFoc = d3.scaleLinear()
  .range(xRange)
  .domain(xDomain);

var xScaleCtx = d3.scaleLinear()
  .range(xRange)
  .domain(xDomain);

var yScaleFoc = d3.scaleLinear()
  .range([heightFoc, 0])
  .domain([0.5, 25.5]);

var xFocTicks = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
  21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
  m2w(0), m2w(1), m2w(2), m2w(3), m2w(4), m2w(5), m2w(6), m2w(7), m2w(8), m2w(9),
  m2w(10), m2w(11), m2w(12), m2w(13), m2w(14), m2w(15), m2w(16), m2w(17), m2w(18),
  m2w(19), m2w(20), m2w(21), m2w(22), m2w(23), m2w(24), m2w(25), m2w(26), m2w(27),
  m2w(28), m2w(29), m2w(30), m2w(31), m2w(32), m2w(33), m2w(34), m2w(35),
  y2w(3), y2w(4), y2w(5), y2w(6), y2w(7), y2w(8), y2w(9), y2w(10), y2w(11), y2w(12)
]

var xAxisFoc2 = d3.axisBottom(xScaleFoc)
  .tickValues(xTicks)
  .tickSize(heightFoc - 5)
  .tickFormat(function(d) { return null; });

var xAxisFoc = d3.axisBottom(xScaleFoc)
  .tickValues(xFocTicks)
  .tickSize(0)
  .tickFormat(function(d) {
    if (d <= 39 && (Math.round(d) % 4) === 0) {
      return d + 'WK';
    } else if (d === 40) {
      return 'BIRTH';
    } else if (d > 39 && d < 196 && (Math.round(w2m(d)) % 6) === 0) {
      return Math.round(w2m(d)) + 'MO';
    } else if (d > 196 && ((Math.round(w2y(d)) + 1) % 2) === 0) {
      return Math.round(w2y(d)) + 'YR';
    } else {
      return null;
    }
  });

var xAxisCtx = d3.axisBottom(xScaleCtx)
  .tickValues(xTicks)
  .tickSize(6)
  .tickFormat(function(d) {
    if (d <= 36) {
      return d;
    } else if (d > 38 && d < 196) {
      return Math.round(w2m(d));
    } else if (d > 196) {
      return Math.round(w2y(d));
    }
  });

var xAxisCtx2 = d3.axisBottom(xScaleCtx)
  .tickValues(xTicks2)
  .tickSize(4)
  .tickFormat(function(d) { return null; });

var xAxisCtx3 = d3.axisBottom(xScaleCtx)
  .tickValues(xTicks3)
  .tickSize(14)
  .tickFormat(function(d) {
    if (d <= 36) {
      return 'CONCEPTION TO PRENATAL (weeks)';
    } else if (d > 38 && d < 196) {
      return 'INFANT TO TODDLER (months)';
    } else if (d > 196 && d < 300) {
      return 'CHILDHOOD TO ADOLESCENCE (years)';
    } else {
      return null;
    }
  });

var brush = d3.brushX()
  .extent([[0, heightCtx], [width, heightCtx + brushHeight]])
  .on('brush end', brushed);

svg.append('defs').append('clipPath')
  .attr('id', 'clip')
  .append('rect')
  .attr('width', width)
  .attr('height', heightFoc);

var context = svg.append('g')
  .attr('class', 'context')
  .attr('transform', 'translate(' + marginCtx.left + ',' + marginCtx.top + ')');

var focus = svg.append('g')
  .attr('class', 'focus')
  .attr('transform', 'translate(' + marginFoc.left + ',' + marginFoc.top + ')');

focus.append('rect')
  .attr('class', 'focus-area')
  .attr('width', width)
  .attr('height', heightFoc);

var gAxisFoc = focus.append('g')
  .attr('class', 'axis axis--x')
  .attr('transform', 'translate(0,' + 5 + ')')
  .call(xAxisFoc)
gAxisFoc.selectAll('text')
  .attr('y', 2)
  .attr('x', 2)
  .style('text-anchor', 'start')
gAxisFoc.selectAll('path')
  .attr('stroke', null)
gAxisFoc.selectAll('line')
  .attr('stroke', null)

var gAxisFoc2 = focus.append('g')
  .attr('class', 'axis axis--x2')
  .attr('transform','translate(0,' + 5 + ')' )
gAxisFoc2.call(xAxisFoc2)
  .selectAll('path')
  .attr('stroke', null)
gAxisFoc2.call(xAxisFoc2)
  .selectAll('line')
  .attr('stroke', '#FFFFFF')
  .attr('stroke-dasharray', '1, 4')
  .attr('stroke-width', 1)
  .attr('stroke-linecap', 'round')

var data = [
  {x: 1       , y: 25},
  {x: 3       , y: 24},
  {x: 9       , y: 23},
  {x: 10      , y: 22},
  {x: 10      , y: 21},
  {x: 14      , y: 20},
  {x: 20      , y: 19},
  {x: 22      , y: 18},
  {x: 28      , y: 17},
  {x: 30      , y: 16},
  {x: 37      , y: 15},
  {x: m2w(5)  , y: 14},
  {x: m2w(6)  , y: 13},
  {x: m2w(9)  , y: 12},
  {x: m2w(12) , y: 11},
  {x: m2w(18) , y: 10},
  {x: m2w(22) , y: 9},
  {x: m2w(28) , y: 8},
  {x: m2w(30) , y: 7},
  {x: m2w(35) , y: 6},
  {x: y2w(4)  , y: 5},
  {x: y2w(5)  , y: 4},
  {x: y2w(6)  , y: 3},
  {x: y2w(9)  , y: 2},
  {x: y2w(11) , y: 1}
];

var dots = focus
  .append('g')
  .attr('class', 'dots')
  .datum(data)
  .selectAll('.dots-group')
  .data(function(d) { return d })
  .enter().append('g')
  .attr('class', 'dots-group')
  .attr('transform', function(d) { return 'translate(' + xScaleFoc(d.x) + ',' + yScaleFoc(d.y) + ')' })

dots.append('text')
  .attr('dx', 8)
  .attr('dy', 12)
  .text(function(d) { return Math.round(d.x) + ' weeks'; })
  .style('fill', 'none')
  .style('font', '10px');

dots.append('circle')
  .attr('class', 'circles')
  .attr('r', 8)
  .style('fill', 'red')
  .on('mouseenter', function() { 
    d3.select(this.parentNode)
      .select('text')
      .style('fill', '#000');
  })
  .on('mouseleave', function() { 
    d3.select(this.parentNode)
      .select('text')
      .style('fill', 'none');
  });



context.append('g')
  .attr('class', 'axis axis--x')
  .attr('transform', 'translate(0,' + heightCtx + ')')
  .call(xAxisCtx)
  .selectAll('text')
    .attr('y', 4)
    .attr('x', 2)
    .attr('fill', unselectColor)
    .style('text-anchor', 'start')

context.append('g')
  .attr('class', 'axis axis--x2')
  .attr('transform','translate(0,' + heightCtx + ')' )
  .call(xAxisCtx2)
  .selectAll('text')
    .attr('fill', unselectColor)

context.append('g')
  .attr('class', 'axis axis--x3')
  .attr('transform','translate(0,' + heightCtx + ')' )
  .call(xAxisCtx3)
  .selectAll('text')
    .attr('fill', unselectColor)
    .style('text-anchor', 'start')

d3.selectAll('.context .domain')
  .attr('stroke', unselectColor)

var gBrush = context.append('g')
  .attr('class', 'brush')
  .call(brush);

var handle = gBrush.selectAll('.handle--custom')
  .data([{type: 'w'}, {type: 'e'}])
  .enter().append('path')
    .attr('class', 'handle--custom')
    .attr('fill', selectColor)
    .attr('cursor', 'ew-resize')
    .attr('d', d3.arc()
      .innerRadius(0)
      .outerRadius(brushHeight / 2)
      .startAngle(0)
      .endAngle(function(d, i) { return i ? Math.PI : -Math.PI; }));

var brushLine = gBrush
  .append('rect')
  .attr('class', 'handle-line')
  .attr('width', 0)
  .attr('height', 1)
  .attr('stroke', selectColor)

gBrush.call(brush.move, [100, 500]);

function findIndex(x, arr) {
  for (let ii = 0; ii < arr.length; ii++) {
    if (x === arr[ii] && ii > 0) {
      return(ii - 1);
    } else if (x <= arr[ii]) {
      return(Math.max(0, ii - 1));
    }
  }
}

function updateXDomainRange(curDom) {
  var xd = [];
  var xr = [];
  var idx1 = findIndex(curDom[0], xDomain)
  var idx2 = findIndex(curDom[1], xDomain)
  var newDomain = [];
  var newRange = [];

  if (idx1 === idx2) {
    newDomain.push(curDom[0], curDom[1]);
    newRange.push(0, width);
  } else if ((idx2 - idx1) === 1) {
    var newLengths = [
      xLengths[idx1] * (xDomain[idx1 + 1] - curDom[0]) / (xDomain[idx1 + 1] - xDomain[idx1]),
      xLengths[idx2] * (curDom[1] - xDomain[idx2]) / (xDomain[idx2 + 1] - xDomain[idx2])
    ];
    var denom = newLengths[0] + newLengths[1];
    newProps = newLengths.map(function(d) { return d / denom; });
    newDomain.push(
      curDom[0],
      xDomain[idx1 + 1],
      curDom[1]
    );
    newRange.push(
      0,
      newProps[0] * width,
      width
    );
  } else if ((idx2 - idx1) === 2) {
    var newLengths = [
      xLengths[idx1] * (xDomain[idx1 + 1] - curDom[0]) / (xDomain[idx1 + 1] - xDomain[idx1]),
      xLengths[idx1 + 1],
      xLengths[idx2] * (curDom[1] - xDomain[idx2]) / (xDomain[idx2 + 1] - xDomain[idx2])
    ];
    var denom = newLengths[0] + newLengths[1] + newLengths[2];
    newProps = newLengths.map(function(d) {return d / denom; });
    newDomain.push(
      curDom[0],
      xDomain[idx1 + 1],
      xDomain[idx1 + 2],
      curDom[1]
    );
    newRange.push(
      0,
      newProps[0] * width,
      (newProps[0] + newProps[1]) * width,
      width
    );
  }
  return { domain: newDomain, range: newRange }
}

function brushed() {
  if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'zoom') return; // ignore brush-by-zoom
  // var s = d3.event.selection || xScaleCtx.range();
  var s = d3.event.selection;
  var curDom;
  if (s) {
    curDom = s.map(xScaleCtx.invert);
    newDR = updateXDomainRange(curDom)
    xScaleFoc.domain(newDR.domain);
    xScaleFoc.range(newDR.range);
    handle.attr('display', null)
      .attr('transform', function(d, i) { return 'translate(' + s[i] + ',' + brushHeight / 2 + ')'; });
    brushLine
      .attr('width', s[1] - s[0])
      .attr('transform', 'translate(' + s[0] + ',' + 0 + ')');
  } else {
    // curDom = [Infinity, Infinity];
    curDom = [xDomain[0], xDomain[xDomain.length - 1]];
    xScaleFoc.domain(xDomain);
    xScaleFoc.range(xRange);
    handle.attr('display', 'none');
    brushLine.attr('width', 0)
  }
  focus.selectAll('.dots-group')
    .attr('transform', function(d) { return 'translate(' + xScaleFoc(d.x) + ',' + (yScaleFoc(d.y) + focAxisPad) + ')' })
  focus.select('.axis--x')
    .call(xAxisFoc)
    .selectAll('text')
    .attr('y', 2)
    .attr('x', 2)
    .style('text-anchor', 'start');

  focus.select('.axis--x2').call(xAxisFoc2);

  d3.selectAll('.context .axis--x text')
    .attr('fill', function(d) {
      return (d >= curDom[0] && d <= curDom[1]) ? selectColor : unselectColor;
    })

  d3.selectAll('.context .axis--x3 text')
    .attr('fill', function(d) {
      if (d === xTicks3[0]) {
        return (curDom[0] <= xTicks3[1]) ? selectColor : unselectColor;
      } else if (d === xTicks3[1]) {
        var inRange = curDom[0] <= xTicks3[2] && curDom[1] >= xTicks3[1];
        return inRange ? selectColor : unselectColor;
      } else if (d === xTicks3[2]) {
        return (curDom[1] >= xTicks3[2]) ? selectColor : unselectColor;
      }
    })

  d3.selectAll('.context .axis line')
    .attr('stroke', function(d) {
      return (d >= curDom[0] && d <= curDom[1]) ? selectColor : unselectColor;
    })
}

</script>
